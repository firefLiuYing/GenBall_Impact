// ============================================================================
// Auto-generated Effect Event System - DO NOT EDIT MANUALLY
// Generated by: EffectEventCodeGenerator.cs
// Generated at: 2026-01-03 16:48:18
// ============================================================================

using GenBall.BattleSystem;
using GenBall.Event;
using GenBall.Player;
using System;
using UnityEngine;
using Yueyn.Base.ReferencePool;
using Yueyn.Event;

namespace GenBall.BattleSystem.Generated
{
    /// <summary>
    /// EffectEventArgs 辅助类
    /// </summary>
    public static class EffectEventArgsHelper
    {
        /// <summary>
        /// 获取事件ID
        /// </summary>
        public static int GetEventId(string eventName)
        {
            return eventName.GetHashCode();
        }
    }

    /// <summary>
    /// Effect事件常量定义
    /// </summary>
    public static class EffectEventConstants
    {
        /// <summary>每帧更新</summary>
        public const string System_Update = "Effect.System.Update";
        /// <summary>固定更新</summary>
        public const string System_FixedUpdate = "Effect.System.FixedUpdate";
        /// <summary>触发输入</summary>
        public const string Input_Trigger = "Effect.Input.Trigger";
        /// <summary>攻击前判定</summary>
        public const string Combat_BeforeAttackJustify = "Effect.Combat.BeforeAttackJustify";
        /// <summary>攻击后结算</summary>
        public const string Combat_AfterAttackCalculate = "Effect.Combat.AfterAttackCalculate";
    }

    /// <summary>
    /// Effect事件ID
    /// </summary>
    public static class EffectEventIds
    {
        /// <summary>每帧更新</summary>
        public static readonly int System_Update;
        /// <summary>固定更新</summary>
        public static readonly int System_FixedUpdate;
        /// <summary>触发输入</summary>
        public static readonly int Input_Trigger;
        /// <summary>攻击前判定</summary>
        public static readonly int Combat_BeforeAttackJustify;
        /// <summary>攻击后结算</summary>
        public static readonly int Combat_AfterAttackCalculate;

        static EffectEventIds()
        {
            System_Update = EffectEventArgsHelper.GetEventId(EffectEventConstants.System_Update);
            System_FixedUpdate = EffectEventArgsHelper.GetEventId(EffectEventConstants.System_FixedUpdate);
            Input_Trigger = EffectEventArgsHelper.GetEventId(EffectEventConstants.Input_Trigger);
            Combat_BeforeAttackJustify = EffectEventArgsHelper.GetEventId(EffectEventConstants.Combat_BeforeAttackJustify);
            Combat_AfterAttackCalculate = EffectEventArgsHelper.GetEventId(EffectEventConstants.Combat_AfterAttackCalculate);
        }

        /// <summary>
        /// 根据事件名获取事件ID
        /// </summary>
        public static int GetId(string eventName)
        {
            return EffectEventArgsHelper.GetEventId(eventName);
        }
    }

    /// <summary>
    /// Effect事件创建工厂
    /// </summary>
    public static class EffectEventFactory
    {
        /// <summary>每帧更新</summary>
        public static EffectEventArgs<Single> CreateSystemUpdate(Single arg1)
        {
            return EffectEventArgs<Single>.Create(EffectEventConstants.System_Update, arg1);
        }

        /// <summary>固定更新</summary>
        public static EffectEventArgs<Single> CreateSystemFixedUpdate(Single arg1)
        {
            return EffectEventArgs<Single>.Create(EffectEventConstants.System_FixedUpdate, arg1);
        }

        /// <summary>触发输入</summary>
        public static EffectEventArgs<ButtonState> CreateInputTrigger(ButtonState arg1)
        {
            return EffectEventArgs<ButtonState>.Create(EffectEventConstants.Input_Trigger, arg1);
        }

        /// <summary>攻击前判定</summary>
        public static EffectEventArgs<IAttackable, AttackInfo> CreateCombatBeforeAttackJustify(IAttackable arg1, AttackInfo arg2)
        {
            return EffectEventArgs<IAttackable, AttackInfo>.Create(EffectEventConstants.Combat_BeforeAttackJustify, arg1, arg2);
        }

        /// <summary>攻击后结算</summary>
        public static EffectEventArgs<AttackResult> CreateCombatAfterAttackCalculate(AttackResult arg1)
        {
            return EffectEventArgs<AttackResult>.Create(EffectEventConstants.Combat_AfterAttackCalculate, arg1);
        }

    }

    /// <summary>
    /// ILocalEventManager扩展方法（类型安全的包装器）
    /// </summary>
    public static class LocalEventManagerExtensions
    {
        #region 订阅扩展方法
        /// <summary>订阅 每帧更新 事件</summary>
        public static void SubscribeSystemUpdate(this ILocalEventManager eventManager, Action<Single> handler)
        {
            eventManager.Subscribe(EffectEventIds.System_Update, (sender, args) =>
            {
                if (args is EffectEventArgs<Single> effectArgs)
                    handler?.Invoke(effectArgs.Args);
            });
        }

        /// <summary>订阅 固定更新 事件</summary>
        public static void SubscribeSystemFixedUpdate(this ILocalEventManager eventManager, Action<Single> handler)
        {
            eventManager.Subscribe(EffectEventIds.System_FixedUpdate, (sender, args) =>
            {
                if (args is EffectEventArgs<Single> effectArgs)
                    handler?.Invoke(effectArgs.Args);
            });
        }

        /// <summary>订阅 触发输入 事件</summary>
        public static void SubscribeInputTrigger(this ILocalEventManager eventManager, Action<ButtonState> handler)
        {
            eventManager.Subscribe(EffectEventIds.Input_Trigger, (sender, args) =>
            {
                if (args is EffectEventArgs<ButtonState> effectArgs)
                    handler?.Invoke(effectArgs.Args);
            });
        }

        /// <summary>订阅 攻击前判定 事件</summary>
        public static void SubscribeCombatBeforeAttackJustify(this ILocalEventManager eventManager, Action<IAttackable, AttackInfo> handler)
        {
            eventManager.Subscribe(EffectEventIds.Combat_BeforeAttackJustify, (sender, args) =>
            {
                if (args is EffectEventArgs<IAttackable, AttackInfo> effectArgs)
                    handler?.Invoke(effectArgs.Args1, effectArgs.Args2);
            });
        }

        /// <summary>订阅 攻击后结算 事件</summary>
        public static void SubscribeCombatAfterAttackCalculate(this ILocalEventManager eventManager, Action<AttackResult> handler)
        {
            eventManager.Subscribe(EffectEventIds.Combat_AfterAttackCalculate, (sender, args) =>
            {
                if (args is EffectEventArgs<AttackResult> effectArgs)
                    handler?.Invoke(effectArgs.Args);
            });
        }

        #endregion

        #region 取消订阅扩展方法
        /// <summary>取消订阅 每帧更新 事件</summary>
        public static void UnsubscribeSystemUpdate(this ILocalEventManager eventManager, Action<Single> handler)
        {
            eventManager.Unsubscribe(EffectEventIds.System_Update, (sender, args) =>
            {
                if (args is EffectEventArgs<Single> effectArgs)
                    handler?.Invoke(effectArgs.Args);
            });
        }

        /// <summary>取消订阅 固定更新 事件</summary>
        public static void UnsubscribeSystemFixedUpdate(this ILocalEventManager eventManager, Action<Single> handler)
        {
            eventManager.Unsubscribe(EffectEventIds.System_FixedUpdate, (sender, args) =>
            {
                if (args is EffectEventArgs<Single> effectArgs)
                    handler?.Invoke(effectArgs.Args);
            });
        }

        /// <summary>取消订阅 触发输入 事件</summary>
        public static void UnsubscribeInputTrigger(this ILocalEventManager eventManager, Action<ButtonState> handler)
        {
            eventManager.Unsubscribe(EffectEventIds.Input_Trigger, (sender, args) =>
            {
                if (args is EffectEventArgs<ButtonState> effectArgs)
                    handler?.Invoke(effectArgs.Args);
            });
        }

        /// <summary>取消订阅 攻击前判定 事件</summary>

        /// <summary>取消订阅 攻击后结算 事件</summary>
        public static void UnsubscribeCombatAfterAttackCalculate(this ILocalEventManager eventManager, Action<AttackResult> handler)
        {
            eventManager.Unsubscribe(EffectEventIds.Combat_AfterAttackCalculate, (sender, args) =>
            {
                if (args is EffectEventArgs<AttackResult> effectArgs)
                    handler?.Invoke(effectArgs.Args);
            });
        }

        #endregion

        #region 触发事件扩展方法（排队）
        /// <summary>触发 每帧更新 事件（排队）</summary>
        public static void FireEventSystemUpdate(this ILocalEventManager eventManager, Single arg1, object sender = null)
        {
            var eventArgs = EffectEventFactory.CreateSystemUpdate(arg1);
            eventManager.FireEvent(sender ?? eventManager, eventArgs);
        }

        /// <summary>触发 固定更新 事件（排队）</summary>
        public static void FireEventSystemFixedUpdate(this ILocalEventManager eventManager, Single arg1, object sender = null)
        {
            var eventArgs = EffectEventFactory.CreateSystemFixedUpdate(arg1);
            eventManager.FireEvent(sender ?? eventManager, eventArgs);
        }

        /// <summary>触发 触发输入 事件（排队）</summary>
        public static void FireEventInputTrigger(this ILocalEventManager eventManager, ButtonState arg1, object sender = null)
        {
            var eventArgs = EffectEventFactory.CreateInputTrigger(arg1);
            eventManager.FireEvent(sender ?? eventManager, eventArgs);
        }

        /// <summary>触发 攻击前判定 事件（排队）</summary>
        public static void FireEventCombatBeforeAttackJustify(this ILocalEventManager eventManager, IAttackable arg1, AttackInfo arg2, object sender = null)
        {
            var eventArgs = EffectEventFactory.CreateCombatBeforeAttackJustify(arg1, arg2);
            eventManager.FireEvent(sender ?? eventManager, eventArgs);
        }

        /// <summary>触发 攻击后结算 事件（排队）</summary>
        public static void FireEventCombatAfterAttackCalculate(this ILocalEventManager eventManager, AttackResult arg1, object sender = null)
        {
            var eventArgs = EffectEventFactory.CreateCombatAfterAttackCalculate(arg1);
            eventManager.FireEvent(sender ?? eventManager, eventArgs);
        }

        #endregion

        #region 立即触发事件扩展方法（立即执行）
        /// <summary>立即触发 每帧更新 事件</summary>
        public static void FireNowSystemUpdate(this ILocalEventManager eventManager, Single arg1, object sender = null)
        {
            var eventArgs = EffectEventFactory.CreateSystemUpdate(arg1);
            eventManager.FireNow(sender ?? eventManager, eventArgs);
        }

        /// <summary>立即触发 固定更新 事件</summary>
        public static void FireNowSystemFixedUpdate(this ILocalEventManager eventManager, Single arg1, object sender = null)
        {
            var eventArgs = EffectEventFactory.CreateSystemFixedUpdate(arg1);
            eventManager.FireNow(sender ?? eventManager, eventArgs);
        }

        /// <summary>立即触发 触发输入 事件</summary>
        public static void FireNowInputTrigger(this ILocalEventManager eventManager, ButtonState arg1, object sender = null)
        {
            var eventArgs = EffectEventFactory.CreateInputTrigger(arg1);
            eventManager.FireNow(sender ?? eventManager, eventArgs);
        }

        /// <summary>立即触发 攻击前判定 事件</summary>
        public static void FireNowCombatBeforeAttackJustify(this ILocalEventManager eventManager, IAttackable arg1, AttackInfo arg2, object sender = null)
        {
            var eventArgs = EffectEventFactory.CreateCombatBeforeAttackJustify(arg1, arg2);
            eventManager.FireNow(sender ?? eventManager, eventArgs);
        }

        /// <summary>立即触发 攻击后结算 事件</summary>
        public static void FireNowCombatAfterAttackCalculate(this ILocalEventManager eventManager, AttackResult arg1, object sender = null)
        {
            var eventArgs = EffectEventFactory.CreateCombatAfterAttackCalculate(arg1);
            eventManager.FireNow(sender ?? eventManager, eventArgs);
        }

        #endregion

    }

    /// <summary>System 相关Effect事件</summary>
    public static class SystemEffectEvents
    {
        /// <summary>每帧更新</summary>
        public static class Update
        {
            public const string Name = EffectEventConstants.System_Update;
            public static int Id => EffectEventIds.System_Update;

            public static EffectEventArgs<Single> Create(Single arg1)
                => EffectEventFactory.CreateSystemUpdate(arg1);

            public static void Subscribe(ILocalEventManager eventManager, Action<Single> handler)
                => eventManager.SubscribeSystemUpdate(handler);

            public static void FireEvent(ILocalEventManager eventManager, Single arg1, object sender = null)
                => eventManager.FireEventSystemUpdate(arg1, sender);

            public static void FireNow(ILocalEventManager eventManager, Single arg1, object sender = null)
                => eventManager.FireNowSystemUpdate(arg1, sender);
        }

        /// <summary>固定更新</summary>
        public static class FixedUpdate
        {
            public const string Name = EffectEventConstants.System_FixedUpdate;
            public static int Id => EffectEventIds.System_FixedUpdate;

            public static EffectEventArgs<Single> Create(Single arg1)
                => EffectEventFactory.CreateSystemFixedUpdate(arg1);

            public static void Subscribe(ILocalEventManager eventManager, Action<Single> handler)
                => eventManager.SubscribeSystemFixedUpdate(handler);

            public static void FireEvent(ILocalEventManager eventManager, Single arg1, object sender = null)
                => eventManager.FireEventSystemFixedUpdate(arg1, sender);

            public static void FireNow(ILocalEventManager eventManager, Single arg1, object sender = null)
                => eventManager.FireNowSystemFixedUpdate(arg1, sender);
        }

    }

    /// <summary>Input 相关Effect事件</summary>
    public static class InputEffectEvents
    {
        /// <summary>触发输入</summary>
        public static class Trigger
        {
            public const string Name = EffectEventConstants.Input_Trigger;
            public static int Id => EffectEventIds.Input_Trigger;

            public static EffectEventArgs<ButtonState> Create(ButtonState arg1)
                => EffectEventFactory.CreateInputTrigger(arg1);

            public static void Subscribe(ILocalEventManager eventManager, Action<ButtonState> handler)
                => eventManager.SubscribeInputTrigger(handler);

            public static void FireEvent(ILocalEventManager eventManager, ButtonState arg1, object sender = null)
                => eventManager.FireEventInputTrigger(arg1, sender);

            public static void FireNow(ILocalEventManager eventManager, ButtonState arg1, object sender = null)
                => eventManager.FireNowInputTrigger(arg1, sender);
        }

    }

    /// <summary>Combat 相关Effect事件</summary>
    public static class CombatEffectEvents
    {
        /// <summary>攻击前判定</summary>
        public static class BeforeAttackJustify
        {
            public const string Name = EffectEventConstants.Combat_BeforeAttackJustify;
            public static int Id => EffectEventIds.Combat_BeforeAttackJustify;

            public static EffectEventArgs<IAttackable, AttackInfo> Create(IAttackable arg1, AttackInfo arg2)
                => EffectEventFactory.CreateCombatBeforeAttackJustify(arg1, arg2);

            public static void Subscribe(ILocalEventManager eventManager, Action<IAttackable, AttackInfo> handler)
                => eventManager.SubscribeCombatBeforeAttackJustify(handler);

            public static void FireEvent(ILocalEventManager eventManager, IAttackable arg1, AttackInfo arg2, object sender = null)
                => eventManager.FireEventCombatBeforeAttackJustify(arg1, arg2, sender);

            public static void FireNow(ILocalEventManager eventManager, IAttackable arg1, AttackInfo arg2, object sender = null)
                => eventManager.FireNowCombatBeforeAttackJustify(arg1, arg2, sender);
        }

        /// <summary>攻击后结算</summary>
        public static class AfterAttackCalculate
        {
            public const string Name = EffectEventConstants.Combat_AfterAttackCalculate;
            public static int Id => EffectEventIds.Combat_AfterAttackCalculate;

            public static EffectEventArgs<AttackResult> Create(AttackResult arg1)
                => EffectEventFactory.CreateCombatAfterAttackCalculate(arg1);

            public static void Subscribe(ILocalEventManager eventManager, Action<AttackResult> handler)
                => eventManager.SubscribeCombatAfterAttackCalculate(handler);

            public static void FireEvent(ILocalEventManager eventManager, AttackResult arg1, object sender = null)
                => eventManager.FireEventCombatAfterAttackCalculate(arg1, sender);

            public static void FireNow(ILocalEventManager eventManager, AttackResult arg1, object sender = null)
                => eventManager.FireNowCombatAfterAttackCalculate(arg1, sender);
        }

    }

}
